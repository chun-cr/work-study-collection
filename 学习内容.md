## 一、小知识点梳理

### 1.`this`指向问题

回调函数中使用普通函数（如`setTYimeout`、`setInterval`)是全局函数，其`this`指向`window`或`undefined`

~~~javascript
mounted(){
    setTimeout(function(){
        // 错误：this 指向 window，无法访问 this.count
        this.count++  //报错：Cannot read property 'count' of undefined
    },1000)
}
~~~

第三方库（如`axios`、`element UI`的回调）中的普通函数，`this`通常是`undefined`或自身库的上下文

~~~javascript
mounted(){
    document.getElementById("btn").addEventListener("click",function(){
        //this指向按钮dom元素
        this.count++ //报错
    })
    
    //axios回调
    axios.get("/api/data").then(function(res) {
        // 错误：this 指向 undefined（严格模式）
        this.msg = res.data  //报错
    })
    
}
~~~

修复以上问题，使用箭头函数，继承上一个作用域的`this`

`vue`会将`data`中的属性，`methods`中的方法，`computed`等，全部挂载到组件实例，组件内的生命周期钩子，`methods`等普通函数，会被`vue`自动绑定`this`为组件实例，而回调函数（如 `setTimeout`、`forEach` 的回调）是独立于组件实例的函数，其 `this` 由函数调用方式决定（全局调用则指向 `window`/`undefined`），因此需要手动绑定。

### 2.`map`对象

`map`支持任意类型作为键（包括对象、函数、基本类型等）

`map`和`Object`的区别

-  一个Object的键只能是字符串或Symbols，但一个Map的键可以是任意值
- Map的键值对是有序地（FIFO原则），而添加到对象中的键不是
- Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。
- Object 都有自己的原型，原型链上的键名有可能和自己在对象上的设置的键名产生冲突。

**基本用法**

~~~javascript
//初始化传入键值对
const map = Map([
    ['name','小春'],
    [123,'数字键'],
    [{id: 1}, '对象键']
])

//创建空map
const map = new Map()

//1.添加
map.set(2,5) //键2值5
map.set(2,4) //再次设置同一键，覆盖值，键2值4

//2.判断是否存在指定键
map.has(3)

//3.获取指定的键
map.get(2)  //如果键存在，就返回对应的值，不存在则返回undefined

//删除键
map.delete(2) //删除成功返回true，键不存在返回false

//清空所有键值对
map.clear()
map.size  //0 查询map里键值对的数量
~~~

**遍历`map`**

~~~javascript
const map = new Map([[2,0], [7,1],[5,6]])

for (const [value,key] of map){
    console.log(`键:${key},值:${value}`)
}

for (const key of map.keys()){
    console.log(`键：${key}`)
}
for (const value of map.values()){
    console.log(`值：${value}`)
}
//forEach遍历
map.forEach((value,key)=>{
    console.log(`键:${key},值:${value}`)
})
~~~

**`map`的合并**

~~~javascript
let first = new Map([[1, 'one'], [2, 'two'], [3, 'three']])
let second = new Map([[1, 'uno'], [2, 'dos']])

// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos,three
let third = new Map([...first, ...second])
~~~

**注意事项：**`map`对象获取键、值迭代器的方式是`.keys()`和`.value()`；`forEach`回调第一个参数是值，第二个参数是键，所以是`map.foreach((value,key) => xxx)`

### 3.`sort()`

`sort`无参数时按字符串的Unicode编码排序，因此：

- 标点/空格 < 数字 < 大写字母 < 小写字母
- 空字符串/特殊字符：空字符串`' '.split('')`会得到空数组，最终结果任为空；包含emoji/多字节字符时，`split('')`可能会拆分错误（需要用`[...str]`代替）

**比较函数**`(a, b) => a - b`

| 比较结果 (`a - b`) | `sort()` 行为       | 最终排序效果 |
| ------------------ | ------------------- | ------------ |
| < 0（负数）        | `a` 排在 `b` 前面   | 升序         |
| = 0                | `a` 和 `b` 位置不变 | 无影响       |
| > 0（正数）        | `b` 排在 `a` 前面   | 升序         |

### 4.`set`（集合）

`set`是无序（没有索引，无法通过下标访问）、不重复、可迭代（如for循环）的数据结构

**常用操作**

~~~javascript
const set = new Set([1,2,2,3])

console.log(set) //Set(3) {1, 2, 3} —— 重复的 2 被自动去除

//添加元素
set.add(4)  ->Set {1,2,3,4}
//删除
set.delete(2)  ->Set {1,3,4}
//判断
set.has(3)  ->true
//获取数量
set.size  ->3
set.clear  ->Set {}

//遍历
const numSet = new Set([10,20,30])
for(let num of numSet){
    console.log(num) // 输出 10、20、30（顺序和插入一致，但无索引）
}
~~~

**类型转换**

~~~javascript
//Set转Array
let mySet = new Set(["value1", "value2", "value3"]);
let myArray = [...mySet]

//String 转set
let setString = new Set('hello') //Set(4) {"h", "e", "l", "o"}
~~~

**`set`对象作用**

~~~javascript
//数组去重
let mySet = new Set([1,2,3,4,4])
console.log([...mySet])

//并集
let a = new Set([1,2,3]) 
let b = new Set([4,2,3]) 
let union = new Set([...a, ...b]) //{1,2,3,4}

//交集
let a = new Set([1,2,3]) 
let b = new Set([4,2,3]) 
let intersect = new Set([...a].filter(x => b.has(x))) //{2,3}

//差集
let a = new Set([1,2,3]) 
let b = new Set([4,2,3]) 
let intersect = new Set([...a].filter(x => !b.has(x))) //{1}
~~~



### 5.`continue`

`continue` 是 JavaScript 中的流程控制语句，用于**跳过当前循环迭代的剩余代码**，直接进入下一次循环迭代。

### 6.`tap`

`tap`轻触事件绑定语法，针对移动端，比`click`响应更快，无300ms延时

~~~javascript
<!-- Vue 中 -->
<button @tap="handleTap">点击我</button>

<!-- 等价于完整写法 -->
<button v-on:tap="handleTap">点击我</button>

<!-- 微信小程序中 -->
<view @tap="handleTap">轻触我</view>

<!-- 小程序也支持 bindtap 写法，和 @tap 等价 -->
<view bindtap="handleTap">轻触我</view>
~~~

### 7.`Array.reduce()`

**遍历数组并将其归约为单个值**（可以是数字、对象、数组等任意类型）。它通过迭代数组的每个元素，逐步累积计算结果，最终返回一个聚合后的值。

~~~javascript
arr.reduce(callback(accumulator, currentValue, currentIndex, array), [initialValue])
~~~

| 参数           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| `callback`     | 遍历数组时执行的回调函数，返回值会作为下一次迭代的 `accumulator` |
| `accumulator`  | 累计器：上一次回调的返回值（或初始值 `initialValue`）        |
| `currentValue` | 当前正在处理的数组元素                                       |
| `currentIndex` | 可选，当前元素的索引（从 0 或 1 开始，取决于是否传初始值）   |
| `array`        | 可选，原数组                                                 |
| `initialValue` | 可选，累计器的初始值。不传时，累计器初始值为数组第一个元素，遍历从第二个元素开始 |

- 遍历过程中**不会修改原数组**；
- 若数组为空且未传 `initialValue`，会抛出 `TypeError`；
- 回调函数的返回值会作为下一次迭代的 `accumulator`，最终返回最终的累计值。

~~~javascript
//数组求和（无初始值）
const number =[1, 2, 3, 4, 5]
// 无初始值时，第一次累计值是数组第一个元素（1），当前值是第二个元素（2）
const sum = number.reduce((acc,curr) => acc + curr)

//数组求和（有初始值）
const number1 =[1, 2, 3, 4, 5]
// 有初始值时，第一次累计值是0，当前值是第一个元素（1）
const sum1 = number.reduce((acc,curr) => acc + curr, 0)

//空数组 + 有初始值不会报错

//空数组 + 无初始值直接报错
~~~

**`reduce`不只是求和，能解决大部分数组迭代问题，替代`map`、`filter`、`forEach`等**

#### 7.1数组求最大/最小值

~~~javascript
const numbers = [5, 2, 9, 1, 5, 6];
const max = numbers.reduce((acc,curr) => {
    return curr > acc ? curr : acc
},-Infinity) //初始值设置成负无穷，兼容所有数字

const min = numbers.reduce((acc, cur) => cur < acc ? cur : acc, Infinity);
console.log(max)
console.log(min)
~~~

#### **7.2数组去重**

~~~javascript
const Arr = [1, 2, 3, 4, 4]
const newArr = Arr.reduce((acc, curr) => {
    if(!acc.includes(curr)){
        acc.push(curr)
    }
},[])
console.log(newArr)
~~~

#### **7.3嵌套数组扁平化**

~~~javascript
const nestedArr = [1, [2, [3, 4], 5], 6];
function flattenArr(arr){
    return arr.reduce((acc,curr) => {
        return acc.concat(Array.isArray(curr) ? flattenArr(curr) : curr)
    },[])
}
console.log(flattenArr(nestedArr))
~~~



### 8.文字溢出显示省略号

~~~javascript
.text-ellipsis {
    white-space: nowrap  //强制单行文本显示
    overflow: hidden
    text-overflow: ellipsis
    /* 必须设置宽度（可固定/百分比/最大宽度），否则容器会随文本自适应，无溢出效果 */
    width: 200px  
}
~~~

### 9.ArrayBuffer和普通buffer的区别

| 维度         | ArrayBuffer（ES 标准）                                       | Node.js Buffer（普通 Buffer）                                |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **所属环境** | 浏览器、Node.js（全 JS 环境支持）                            | 仅 Node.js 环境（早期为弥补浏览器 Buffer 缺失）              |
| **本质**     | 原始二进制数据的 “固定长度容器”（不可直接操作）              | `Uint8Array` 的子类（可直接读写、兼容 Node API）             |
| **可操作性** | 不能直接读写，需通过 TypedArray（如 Uint8Array）/ DataView 操作 | 可直接通过下标读写（如 `buf[0] = 12`），API 更丰富           |
| **长度特性** | 长度固定，创建后无法修改（需新建再拷贝）                     | 长度可动态调整（如 `buf.resize()`）                          |
| **编码支持** | 无内置编码转换（需手动处理）                                 | 内置 UTF-8/GBK/Base64 等编码转换（如 `buf.toString('utf8')`） |
| **内存管理** | 由 JS 引擎垃圾回收管理                                       | 可手动控制内存（如 `Buffer.allocUnsafe` 避免初始化）         |
| **兼容性**   | 浏览器 / 小程序（如 uni-app）优先支持                        | 仅 Node.js 环境，浏览器不支持                                |

1.`ArrayBuffer`只读容器，本身只是一块二进制内存区域，不能直接读取或修改，必须通过「`TypedArray`（如 `Uint8Array`/`Int16Array`）」或「`DataView`」来操作：

~~~javascript
let buffer = new ArrayBuffer(10)
let dataView = new DataView(buffer)
dataView.setInt8(0,1)
console.log(dataView(0)) //1
~~~

`DataView` 的作用就是「给这个二进制容器配工具」—— 它可以通过各种方法（如 `setInt8`/`getInt8`/`setFloat32` 等），按指定的「数据类型」读写 `ArrayBuffer` 中的二进制数据，且支持灵活指定「起始字节位置」

**关键属性**

- buffer：返回关联的`ArrayBuffer`实例
- `byteOffset`：返回 `DataView` 相对于 `ArrayBuffer` 的起始偏移量
- `byteLength`：返回 `DataView` 可操作的字节长度

~~~javascript
// 1. 创建一个长度为 10 字节的 ArrayBuffer
const buffer = new ArrayBuffer(10);

// 2. 创建覆盖整个 buffer 的 DataView（最常用）
const dataView = new DataView(buffer);

// 3. 仅操作 buffer 中第 2~5 字节（偏移 1，长度 4）
const partialView = new DataView(buffer, 1, 4);
~~~

方法语法：`dataView.setInt8(byteOffset, value)`

|   组成部分   |                             含义                             |
| :----------: | :----------------------------------------------------------: |
|  `setInt8`   | 方法名，代表「向 `ArrayBuffer` 中写入一个 8 位（1 字节）有符号整数」。 |
| `byteOffset` | 「字节偏移量（byteOffset）」：指定从 `ArrayBuffer` 的第几个字节开始写（索引从 0 开始）。这里 `0` 表示 “从第 0 个字节（第一个字节）开始写”。 |
|   `value`    | 「要写入的值（value）」：必须是符合「8 位有符号整数范围」的值（范围：`-128 ~ 127`）。这里 `1` 是合法值，会被转成二进制写入指定字节。 |

~~~javascript
//创建8字节的buffer
const buffer = new ArrayBuffer(8)
//通过Unit8Array视图操作(按无符号8位整数读取)
const unit8View = new Unit8Array(buffer)
unit8View[0] = 255 //修改第一个字节
console.log(unit8View[0]) //255
~~~

2.`Node.js` `Buffer`:更易用的二进制工具

~~~javascript
const buf = Buffer.from('hello','utf8') //创建buffer实例的方法
console.log(buf[0]) //104('h'的utf-8编码)
console.log(buf.toString('base64'))  // aGVsbG8=（编码转换）
buf.write('world', 1); // 直接修改指定位置
~~~

3.相互转换

~~~javascript
//1.ArrayBuffer -> node.js Buffer
const arrayBuffer = new ArrayBuffer(8)  //创建一个指定大小的空 Buffer
const nodeBuffer = Buffer.from(arrayBuffer)

//2.node.js Buffer -> ArrayBuffer
const nodeBuf = Buffer.alloc(8)
const arrayBuf = nodeBuf.buffer  //共享同一块内存
~~~

>  📌`undefined`类型是`undefined`,`null`类型是`Object`

### 10.`slice(start,end)`

用于**截取数组的指定部分**，返回一个包含截取元素的**新数组**，**不会修改原数组**。

1.`start`(可选)：截取的**起始索引**（从 0 开始计数），默认值为 `0`。

- 传入正数：从对应索引开始截取（包含该索引的元素）。
- 传入**负数**：从数组末尾向前倒数（`-1` 表示最后一个元素，`-2` 表示倒数第二个，以此类推）。

- 传入的值超过数组长度：返回空数组 `[]`。

2.`end`（可选）：截取的**结束索引**，默认值为 `数组长度`（即截取到数组末尾）。

- 传入**正数**：截取到对应索引**停止**（不包含该索引的元素，「左闭右开」）。
- 传入**负数**：从数组末尾向前倒数，截取到该位置停止（不包含该位置的元素）。
- 若`end <= start`:返回空数组[]

3.**返回值 `newArray`**：包含从 `start` 到 `end`（不包含 `end`）的所有元素的新数组。

### 11.定型数组

没太看懂这个、、也不知道什么时候会用，用到了再看一遍吧、

### 12.`some()`和`indexOf()`

`indexOf()` 是数组 / 字符串的原型方法，**核心作用是查找「指定元素」在数组 / 字符串中首次出现的索引**，找不到则返回 `-1`。

>  基本语法：`array.indexOf(searchElement, [fromIndex])`

- `searchElement`：要查找的目标元素（必须）。

- `fromIndex`：可选，从数组的哪个索引开始查找（默认 `0`，支持负数，负数表示从数组末尾倒数）。

- 返回值：**数字**。找到元素返回其「首次出现的索引」，找不到返回 `-1`。

- 对于引用类型（如对象、数组），无法正确查找（因为引用类型比较的是内存地址，而非内容）：

  ~~~javascript
  const persons = [{ name: '张三' }, { name: '李四' }];
  console.log(persons.indexOf({ name: '张三' })); // -1（两个对象内存地址不同，即使内容一致）
  ~~~

`some()` 是数组的原型方法，**核心作用是判断数组中「是否存在至少一个元素满足自定义条件」**，满足返回 `true`，不满足返回 `false`。

> 基本语法： `array.some((currentValue, index, array)) => {}, [thisArg]`

- 回调函数（必须）：遍历数组时对每个元素执行的判断逻辑，接收 3 个参数：
  - `currentValue`：当前遍历到的数组元素。
  - `index`：当前元素的索引。
  - `array`：调用 `some()` 方法的原数组。
- `thisArg`：可选，指定回调函数中 `this` 的指向。
- 返回值：**布尔值**。只要有一个元素满足回调条件，立即返回 `true`；所有元素都不满足，返回 `false`。
- 遍历特性：「短路遍历」—— 一旦找到满足条件的元素，就停止后续遍历，提升效率。





















## 二、大知识点梳理

### 1.虚拟滚动（附链接）

[新手也能看懂的虚拟滚动实现方法本篇文章致力于小白也能懂的虚拟滚动实现原理，一步一步深入比较以及优化实现方案，内容浅显易懂 - 掘金](https://juejin.cn/post/6844904183582162957#heading-3)
